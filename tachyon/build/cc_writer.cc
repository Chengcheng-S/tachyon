#include "tachyon/build/cc_writer.h"

#include <string>
#include <vector>

#include "absl/strings/str_join.h"
#include "absl/strings/str_replace.h"
#include "absl/strings/substitute.h"

#include "tachyon/base/containers/container_util.h"
#include "tachyon/base/logging.h"
#include "tachyon/base/strings/string_util.h"

namespace tachyon::build {

namespace {

// clang-format off
// Case 1. If your build target tries to generate //tachyon/math/elliptic_curves/bn/bn254/g1.h,
// then |components| will be ["bazel-out", "k8-fastbuild", "bin", "tachyon", "math", "elliptic_curves", "bn", "bn254", "g1.h"]
// Case 2. If your build target tries to generate @kroma_network_tachyon//tachyon/math/elliptic_curves/bn/bn254/g1.h,
// then |components| will be ["bazel-out", "k8-fastbuild", "bin", "external", "kroma_network_tachyon", "tachyon", "math", "elliptic_curves", "bn", "bn254", "g1.h"]
// This functions returns 3 for Case 1 and 5 for Case 5.
// clang-format on
size_t CountBazelParts(const std::vector<std::string>& components) {
  CHECK_EQ(components[0], "bazel-out");
  CHECK_EQ(components[2], "bin");
  if (components[3] == "external") {
    return 5;
  }
  return 3;
}

base::FilePath BazelOutToHdrPath(const base::FilePath& out) {
  std::vector<std::string> components = out.GetComponents();
  size_t non_bazel_part = CountBazelParts(components);
  base::FilePath header_path(absl::StrJoin(components.begin() + non_bazel_part,
                                           components.end() - 1,
                                           base::FilePath::kSeparators));
  header_path = header_path.Append(
      absl::StrCat(out.BaseName().RemoveExtension().value(), ".h"));
  return header_path;
}

std::string BazelOutToHdrGuardMacro(const base::FilePath& out) {
  std::vector<std::string> components = out.GetComponents();
  size_t non_bazel_part = CountBazelParts(components);
  base::FilePath header_path(absl::StrJoin(components.begin() + non_bazel_part,
                                           components.end() - 1,
                                           base::FilePath::kSeparators));
  // In case of .cu.h, it removes extension twice.
  base::FilePath basename = out.BaseName().RemoveExtension().RemoveExtension();
  return base::ToUpperASCII(
      absl::StrCat(absl::StrJoin(components.begin() + non_bazel_part,
                                 components.end() - 1, "_"),
                   absl::Substitute("_$0_H_", basename.value())));
}

}  // namespace

base::FilePath CcWriter::GetHdrPath() const { return BazelOutToHdrPath(out); }

int CcWriter::WriteHdr(const std::string& content, bool c_api) const {
  std::string_view tpl[] = {
      "// This is generated by %{generator}",
      "#ifndef %{header_guard_macro}",
      "#define %{header_guard_macro}",
      "",
      "%{content}",
      "%{extern_c_back}",
      "#endif  // %{header_guard_macro}",
      "",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string_view extern_c_front =
      "#ifdef __cplusplus\n"
      "extern \"C\" {\n"
      "#endif";

  std::string_view extern_c_back =
      "\n"
      "#ifdef __cplusplus\n"
      "}  // extern \"C\"\n"
      "#endif\n";

  tpl_content = absl::StrReplaceAll(tpl_content, {
                                                     {"%{content}", content},
                                                 });

  std::string text = absl::StrReplaceAll(
      tpl_content,
      {
          {"%{generator}", generator},
          {"%{header_guard_macro}", BazelOutToHdrGuardMacro(out)},
          {"%{extern_c_front}", c_api ? std::string(extern_c_front) : ""},
          {"%{extern_c_back}", c_api ? std::string(extern_c_back) : ""},
      });
  return Write(text);
}

int CcWriter::WriteSrc(const std::string& content) const {
  std::vector<std::string_view> tpl = {
      "// This is generated by %{generator}",
      "#include \"%{header_path}\"",
      "",
      "%{content}"
      "",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string text = absl::StrReplaceAll(
      tpl_content, {
                       {"%{generator}", generator},
                       {"%{header_path}", GetHdrPath().value()},
                       {"%{content}", content},
                   });
  return Write(text);
}

// static
bool CcWriter::DoRemoveOptionalLines(std::vector<std::string>& tpl_lines,
                                     std::string_view start_line,
                                     std::string_view end_line,
                                     bool select_tag_block) {
  auto result = base::FindIndex(tpl_lines, start_line);
  if (!result.has_value()) return false;
  size_t start_idx = result.value();

  result = base::FindIndex(tpl_lines, end_line);
  CHECK(result.has_value()) << "The tag starts but not ends";
  size_t end_idx = result.value();

  if (select_tag_block) {
    // Remove the first |start_line| and |end_line|.
    tpl_lines.erase(tpl_lines.begin() + start_idx);
    tpl_lines.erase(tpl_lines.begin() + end_idx - 1);

  } else {
    // Remove lines between |start_line| and |end_line|.
    tpl_lines.erase(tpl_lines.begin() + start_idx,
                    tpl_lines.begin() + end_idx + 1);
  }
  return true;
}

// static
void CcWriter::RemoveOptionalLines(std::vector<std::string>& tpl_lines,
                                   std::string_view tag,
                                   bool select_tag_block) {
  std::string start_line = absl::Substitute("%{if $0}", tag);
  std::string end_line = absl::Substitute("%{endif $0}", tag);
  bool result = true;
  while (result) {
    result = DoRemoveOptionalLines(tpl_lines, start_line, end_line,
                                   select_tag_block);
  }
}

}  // namespace tachyon::build
